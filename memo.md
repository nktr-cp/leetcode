## 考えたこと (step1)
設定としてはマージソートっぽい，一つづつスライドして最小を構成しそうな雰囲気がある？ -> 無理そうだった

最もナイーブに解くと全ペアを比較してどんなに頑張ってもO(nums1.length * nums2.length)はかかる，これをどう減らすか．

動くものが2つある問題は一方を固定するのが典型なので，とりあえずその方針で考えたい．一方を固定してもう一方をインデックスの小さい方から見れば二要素の和について狭義の単調性が言える．

ここを上手にやりたかったが，うまいやり方が思いつかなかったのでとりあえず和の小さいトップk個を保持し，一つでも現状のトップkを超えれば単調性からそれ以降は見ないで良いことが言える．

計算量が収まることを示してなかったが，お祈りで提出したところacceptされた．

## 時間・空間計算量 (step1)
### 空間計算量
O(k)

### 時間計算量
nums1 = [1, 1, ..., 1] (10^5個)

nums2 = [10^8, 10^8 + 1, ..., 10^8 + 10^5 - 1]

k = 10^4

などで最悪ケースになる気がする．

これで最悪になる，と言うのが正しければ，最初のループでk回，二回目でk/2回，三回目でk/3回となって，k+1回目以降は0回になる．

そこで，計算量はO(k logk)で抑えられる．

heapのpush操作にO(log k)かかるので，O(k (logk)^2)な気がするがあまり自信はない...

## 考えたこと (step2)
まず，タプルも構造化束縛を使える．特に`get`で要素を取るのが結構嫌だと思っていたので，これは使っていきたい．

https://github.com/SuperHotDogCat/coding-interview/pull/44/files
https://github.com/olsen-blue/Arai60/pull/10/files

ダイクストラで解けるらしい，全然この解法は見えなかったが，これが想定解法感がある．

sumがコストになっていて，こういう解釈をすれば自明にダイクストラに構成ができる．

訪問済みかを管理するフラグはstd::unordered_setを使いたかったが，pairに対して使うのが厄介そうだったので断念，デフォルトだとpairに対してのハッシュ関数がないかららしい．

まあ今回はインデックスを管理したいだけなので，キャストして，`i << 32 | j`みたいにエンコードすれば使えるけど，そこまではやらないでいいかなと思った．

https://stackoverflow.com/questions/15160889/how-can-i-make-an-unordered-set-of-pairs-of-integers-in-c

