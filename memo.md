## 考えたこと (step1)
二つ同時に動かすと二重ループになって計算が重くなってしまうので，一つを固定し，残りから，`target - nums[i]`を見つける．

残りの探索をする上で検索用のソート済みの配列があると嬉しい．今回は特定の要素をカウントしたいので，multisetを用意．

二分探索をかけて，見つかった場合のみそのインデックスを探す．そうすれば線形探索の回数は1回で済むので，十分高速に動作する．

つがいになる要素のインデックスは自分より先のインデックスから探してくることに注意．これは素数判定がO(sqrt(N))でできるのと同じような考え方で，先に登場したインデックス目線でペアを探せば良い．

この問題はテストケースがかなり優しくて，考えるべきケースがわかった．

## 時間・空間計算量 (step1)
Nをnums.lengthとする．

空間計算量は索引用の配列が支配的で，O(N)．

時間計算量は，ソートと対になる要素の検索でO(N logN)
