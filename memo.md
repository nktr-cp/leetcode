## 考えたこと (step1)
ソート済みなので，前から順番に見ていって重複している部分をスキップしてノードの繋ぎ換えをすればよい．

そのためには今見ているノードと，重複が無くされた時その次にくるノードを持っておき，それらを直接繋ぎ直せばよい．

やることは割とすぐにわかったのだが，whileの二重ネストを書いてしまって，終了条件に間違いがあってWAしてしまった．

中のwhileの中でreturnする時の条件
```cpp
if (next_node == nullptr) {
	current_node->next = nullptr;
	return head;
}
```

外のwhileが終わった後のreturnする時の条件
```cpp
return head;
```

この辺りが合っているかの検証をかなりごちゃごちゃ考えないといけなくて，色々なケース (ノード1個，重複なしなど) で正しく動作するかを考えるのがつらい．

step2でなるべく頭を使わないで済むいい書き方がないかを探してみる．

## 時間・空間計算量 (step1)
空間計算量はO(1)，時間計算量は各ループ内の処理がO(1)で終わるので，全体ではO(N)．

## 考えたこと (step2)
少なくとも，
```cpp
if (next_node == nullptr) {
	current_node->next = nullptr;
	return head;
}

current_node->next = next_node;
```

これは冗長で，
```cpp
current_node->next = next_node;
```
は共通で書いてしまって，

```cpp
if (next_node == nullptr) {
	return head;
}
```
もしくは
```cpp
if (next_node == nullptr) {
	break;
}
```

のほうがよい．
returnは一箇所にまとめる方がわかりやすいと思ったので，下で書くことにした．

外のwhileループをいつ抜けるのかが分かりにくいので，while(1)として，breakで抜けることを明示した．

## 時間・空間計算量 (step2)
リファクタリングしただけなので，変化なし．

## 考えたこと (step3)
1分半くらいでかけるようになった．

step1のコードと比べると処理ごとにブロックが分けられている感じがして，必然性をもって書けるコードになったのではないか．

## 考えたこと (step4)
> while (current_node) で回して、next_node = current_node->next とはじめにしたら、後ろのほうが楽になるように思いました。
> ループを回すときに引き継いでいる内容が単純になるからですね。

こうすると考えたことにより対応したコードになっているし，`next_node`のスコープが狭まって，今何が入ってるんだっけ？を考えなくて良くなる．
