## 考えたこと (step1)
各文字列の登場頻度を記録した配列と，その元の文字列を保持する配列を対応させるmapがあればよい．

入力文字列は小文字アルファベットだけなので，サイズ26のvectorを作ればそれをキーにして動かせる気がする．

ただ，キーをあまり複雑にすると，orderedなmapだとそもそも比較が大変，unorderedなmapだとカスタムのハッシュ関数を与えないといけなくて，考えないといけないことが多くなって嬉しくない，どうするか．

結局，同じ文字の登場頻度をもつ二つの文字列が一意に同じキーを与えればよい，と言う話なので，各文字列をソートしたものをキーとして，バリュー側に元の文字列を持たせれば良い．

ソートに時間がかかるが，文字列長は100なので，充分気にならない速さで行えるはず．結局この方針で8分くらいでaccept．

ただし，変数の命名にかなり悩んで，相当改善の余地があると思う．

## 時間・空間計算量 (step1)
n := strs.length, m := strs[i].lengthとして，時間計算量はO(nmlogm)，空間計算量はO(nm)．

## 考えたこと (step2)
https://github.com/SuperHotDogCat/coding-interview/pull/13/files
https://github.com/hayashi-ay/leetcode/pull/19/files
https://github.com/nittoco/leetcode/pull/13/files

発想は大体同じことをしている．結構思考のプロセスが近い気がしていて，

> 入力文字列は小文字アルファベットだけなので，サイズ26のvectorを作ればそれをキーにして動かせる気がする．

この配列から文字列を復元してキーにするというのが考えられていた．これはソート済みの文字列をランレングス圧縮したものになって，quick sortしているところがbucket sortになってるだけなので，まあ本質的に変わらないかという気持ちになった．

色々読んで変数名を検討する．自分はanagramという英単語を知らなかったが，これがぴったり使えそう．

正確に表現するなら，`sorted_string_to_anagrams`とかになる気がするが，これはちょっと長すぎて嫌だなと思ってしまう．この辺の感覚はみなさんどうなんでしょう．
